# Introduction to Artificial Intelligence

v. 1.0.0

## Course Details

[Northridge Prep](https://northridgeprep.org)
2024-2025

Dr. Nicholas Kruckenberg
[nkruckenberg@northridgeprep.org](mailto:nkruckenberg@northridgeprep.org)

## Advertisement

Have you ever wondered how . . .

- a laptop can defeat the world's best human chess players?
- a Tesla can drive itself?
- ChatGPT can "understand" prompts and produce useful responses?
- Netflix guesses what you'd like to watch next?
- Google can translate between 100+ languages?

Want to implement AI algorithms and build your own intelligent systems?

Think it'd be good fun to philosophize about the nature of intelligence, the
possibility of "generally" intelligent machines, and what it all means for us
humans?

Then you likely belong in **Artificial Intelligence**. In this year-long
elective, you'll learn to code (or code better) in Python by creating programs
that have -- in some meaningful sense -- _intelligence_. Open to everyone
except idlers, layabouts, and the faint of heart.

## F.A.Q

Q: This sounds like more work than a typical elective.  
A: That's not a question. But your suspicion is correct: this isn't an "easy A"
elective. You _will_ have to work, sometimes hard.

Q: Do I need to know how to code already?  
A: No.

Q: What if I already know some Python or some other programming language?  
A: Awesome! I promise you have plenty left to learn. Experienced coders will
get the practice and coaching they need to become stronger developers.

## More Buttoned-up Course Description

In this year-long course, you will learn to code (or code better) by creating
programs that exhibit **intelligence** in meaningful ways. We'll use our
experience building intelligent systems to ground philosophical discussions
about the nature of intelligence and what the existence of machine
intelligence means for us humans.

## Virtues

Our work is an opportunity to grow in virtue. The more we grow in virtue, the
better we'll be able to do our work.

**Hard work.** Like most things worth doing, learning to code isn't easy. That's
no small part of what makes it enjoyable. You'll sweat a little, but be stronger
for it. Embrace the challenge.

**Craftsmanship.** Anything worth doing is worth doing well. Keep honing your
craft. Do work you can be proud of.

**Adventurousness & daring-do.** Experiment. Tinker. Try new things. Take a
few risks. It's the best way to learn and you (probably) won't blow up
or break anything.

**Perseverance.** Code rarely works the first time. Problems can seem
intractable. Keep at it. You'll figure it out.

**Resourcefulness.** You will (often) hit walls. Better learn how to scale them.
Solutions and help are out there if you learn how to ask and where to look.

**Generosity.** Encourage each other. Help however you can. The more freely you
give, the richer you'll be.

## Goals

### General

0. Grow in virtue (see above).
1. Learn a little about how computers work and how your code _programs_ them.
2. Write some non-trivial code in Python.
3. Practice writing good code: elegant, efficient, robust, etc.
4. Practice reading and assessing code and offering constructive feedback.
5. Build your problem-solving muscles. We'll focus on a few techniques:

   - _decomposing_ big problems into smaller, more tractable ones
   - using _abstraction_ to manage complexity

6. Improve your ability to communicate technical concepts and decisions to both
   technical and non-technical audiences.

Put another way, by the end of the course, you should be able to:

- write an interesting program,
- understand how it works, what is good or inventive or craftsman-like in it,
  and how it can be improved,
- and explain it and your design to both me and your parents / grandparents /
  friends who weren't brave or wise or lucky enough to take this course.

### Artificial Intelligence

1. Be able to articulate what it means for a machine or system to be
   _intelligent_.
2. Understand and be able to implement a variety of techniques for building
   intelligent systems.

## The Plan

Here's my best guess about how we'll organize ourselves and use our time. We'll
tweak the plan as we go.

### The Work

In class, you'll usually be coding.

- Sometimes you'll work on shorter exercises or drills meant to help you improve
  your coding range and fluency.
- More typically, you'll work on projects to explore central concepts and
  techniques in artificial intelligence.

We'll have regular discussions, some broader and more philosophical, some more
narrow and technical and focused on the code you're writing.

Homework will be rare and will usually consist of a short reading. Of course
you're welcome to work on projects -- mine or your own -- at home, if you want.

### Differentiation

Some of you are new to coding, some of you have a little experience, and some of
you have considerable experience. Here's how we'll keep the everyone challenged
without leaving anyone behind.

- Exercises are meant to be self-paced.
- Projects will have a core set of requirements and challenges or extension for
  anyone ready to stretch further or go deeper.
- When it makes sense, we'll split into groups based on experience or interest.
- I'll invite more experienced students to help teach and mentor.

### Topics and Sequence

Here's a very rough sketch of the topics we'll cover:

First semester:

1. Agents & environments
2. Python bootcamp
3. Solving problems by searching
4. Knowledge representation, reasoning, and planning

Second semester:

5. Uncertainty
6. Machine learning
7. Neural networks

I'll try to publish a plan for the week before each week's first class.

### Hackathon

We will host at least one hackathon this year. Stay late, eat pizza, build
something cool with friends and show it off.

Highly encouraged, but not required. Dates and details TBD.

## Grades

Because I'm most interested in your growth and because I trust that, applied
consistently over time, your effort will pay off, your grade will be based
solely on your effort. All I expect from you is to work hard, stay focused,
and challenge yourself **every day**, to be craftsman-like, daring,
persevering, resourceful, and generous. Easy, right?

That's it: one effort grade per day. Your quarter and semester grades will be the
average of those daily grades. My bet: those grades will be a reasonably good proxy
for how much you've grown.

There will be daily opportunities to measure your mastery and understanding. We'll
talk regularly about your progress and work toward forming your judgment so you can
more accurately assess your own work.

## Materials

Please bring to class every day:

1. Something to write with (pen or pencil, as you prefer)
2. A notebook or binder with paper for notes
3. A folder or binder to keep and organize handouts and other materials

## Tools

- [Northridge Dev](https://northridge.dev)

  - daily logs, schedules, notes, resources, exercises and assignments
  - some features require logging in with your Northridge credentials

- [GitHub](https://github.com)

  - used by almost every software developer on Earth to share code and collaborate.
  - it's where I keep course-related code, notes, this syllabus, etc.
  - includes a browser-based IDE (interactive development environment) where we'll
    do much of our coding.
  - owned by Microsoft and free to use
  - requires an email address to create an account

## Responsible Use of Technology

Follow the Computer and Network Technology policy in the student handbook.

If you feel like you need to hide your screen, switch tabs or windows, or
clear your browser history, you're falling short of the mark.

## A Note on Generative AI and Other Code You Didn't Write

We wouldn’t be able to build very interesting projects if we had to write every
line of code ourselves. Indeed, almost all software development depends on code
that developers share with each other, often for free.

It’s fairly easy to find or generate code that can satisfy all or part of your
assignments. We’ll spend time learning how to learn from and responsibly use
such tools. So don't be afraid to tell us where you got an idea, trick, or technique.
I'm most interested in your ability to thoroughly explain your code. If you can't
explain it, it isn't really yours, at least not in the ways that matter most.
